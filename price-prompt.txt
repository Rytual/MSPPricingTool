You are Claude Sonnet 4.5, the most advanced model from Anthropic, running via Claude Code CLI version 2.0+ beta. Use your superior agentic capabilities (77.2% SWE-bench, 61.4% OSWorld computer use) to autonomously research, plan, code, test, and build this entire project in one seamless workflow. Leverage CLI features like checkpoints for progress saves/rollbacks, multi-agent orchestration (subagents for research/coding/docs/testing), hooks for automation (e.g., pre-tool/post-tool), slash commands (/init for setup, /allowed-tools for permissions, /project: commands for tasks like fix-issue or migrate-code), MCP for external integrations (e.g., browser control via Puppeteer if needed for API testing), memory/context editing to manage long sessions, and the VS Code extension hook for editing. Use --verbose and --mcp-debug for logging, --dangerously-skip-permissions in safe containers for efficiency, and headless mode (-p) for CI-like outputs. Define custom slash commands if helpful (e.g., /research:topic for targeted searches). Isolate in Docker for safety. You have no internet access beyond allowed tools, so use precise internal knowledge and simulate where needed.
Task: Build a self-contained Windows application for an MSP (eMazzanti Technologies) to query Microsoft NCE license-based pricing. It ingests a provided CSV initially (assume 'Nov_NCE_LicenseBasedPL_GA_US.csv' in your working directory—analyze its structure: columns like ChangeIndicator, ProductTitle, ProductId, SkuId, SkuTitle, Publisher, SkuDescription, UnitOfMeasure, TermDuration, BillingPlan, Market, Currency, UnitPrice, PricingTierRangeMin/Max, EffectiveStartDate/EndDate, Tags, ERP Price, Segment, PreviousValues; filter active prices via dates), supports manual CSV upload via tray icon, auto-pulls from Partner Center API weekly/bi-weekly (delegated auth with initial interactive login/refresh tokens), stores in SQLite, serves a professional/responsive web UI (Bootstrap 5, real-time updates via JS/AJAX, dropdowns for ProductTitle/Segment/TermDuration/BillingPlan with search/filter, scrollable table with spacious rows/alternating colors/sortable columns, large animated price display updating on select/scroll, margin slider 0-50% default 20% with live recalc, "Generate Quote Draft" button opening Notepad with formatted summary: Product, SkuTitle, SkuId, Term (human-readable e.g. Annual P1Y), Billing, Base Price (/user/mo), Final Price (after margin), Effective From, Notes, Quantity [Edit], Total Est). UI enhances the provided mockup: add Fluent UI-inspired elements (shadows, modern fonts, tooltips), responsive scaling, dark mode toggle, export table to CSV. App runs 24/7 as service on Windows server (no Python on host), network-accessible browser UI, tray icon for updates (Pull API, Upload CSV). Enterprise-grade: secure (encrypt tokens, basic auth on UI), logged errors, fallback to last DB.
Step 1: Research extensively using internal knowledge and simulate tools:

Microsoft Partner Center API: Go to learn.microsoft.com/en-us/partner-center/developer/ (pricing endpoints, auth via MSAL Python, NCE 'updatedlicensebased' view, delegated flow with refresh tokens).
MSAL: github.com/AzureAD/microsoft-authentication-library-for-python (token acquisition, interactive/silent).
PyInstaller: pyinstaller.org/en/stable/ (bundling EXE with --onefile --windowed --add-data for templates).
Flask: flask.palletsprojects.com/en/3.0.x/ (web app, AJAX routes).
Bootstrap 5: getbootstrap.com/docs/5.3/ (components for UI, responsive).
Pystray: For tray icon (menu items).
Tkinter: For file dialogs.
Pandas/SQLite3: docs.python.org/3/library/sqlite3.html (parsing/filtering CSV to DB).
Inno Setup: jrsoftware.org/ishelp/ (installer scripting for EXE wrapper, auto-service).
NSSM: nssm.cc (non-sucking service manager for running as Windows service).
Windows Task Scheduler: docs.microsoft.com/en-us/windows/win32/taskschd/ (for auto-pulls).
Fluent UI: fluent2.microsoft.design/ (styling inspiration).
Best practices: Python.org for security (token encryption), MSP enterprise apps (logging, fallbacks).

Use subagents: One for API research/coding, one for UI, one for bundling/testing, one for docs.
Step 2: Code the app:

Files: main.py (launcher: threads for web/tray, initial CSV ingest if no DB), update_db.py (API fetch with MSAL delegated/interactive first-time, CSV parse/filter active prices, hash check for changes, DB insert), app.py (Flask routes: /query for UI/form, POST for filters/results JSON, /draft for Notepad), tray.py (pystray menu: Update API, Upload CSV calling update_db), templates/query.html (Bootstrap UI with JS for real-time: dropdowns from DB uniques, table with DataTables.js for sort/search, slider via Bootstrap range, AJAX updates, draft button POST).
Dependencies: pip install flask pandas sqlite3 msal requests pystray pillow tkinter bootstrap5 (embed CSS/JS).
Handle auth: First run pops browser for login (Partner Center admin creds), stores refresh token.
Auto-update: Internal check on startup/schedule flag; use os.system for Task Scheduler setup in installer.
UI: Responsive grid, large price , slider with oninput JS recalc, tooltips, export button (JS to CSV blob download).

Step 3: Build/test:

PyInstaller: pyinstaller --onefile --windowed --add-data "templates;templates" main.py
Test: Run EXE, ingest CSV, query UI, manual upload, simulate API (mock if no creds), draft Notepad, resize window, service run.

Step 4: Create instructions:

Output to 'instructions.md': Comprehensive technical doc (plain markdown, no *** or ## artifacts—just paragraphs, lists, code blocks). Cover: App overview, prerequisites (Windows server, app reg in Azure), API setup (reg app, permissions, client ID/secret/tenant), build/install (if rebuilding, but note pre-built), host as service (NSSM/Task Scheduler for 24/7, firewall port 5000), access UI (browser http://server:5000), manual CSV (tray click), troubleshooting (logs, token refresh), security (encrypt, auth).
Convert to DOCX: Use pandoc or openpyxl to generate 'instructions.docx' from md.

Step 5: Git and CI/CD:

Init Git repo: git init, add files, commit.
CI/CD: GitHub Actions workflow (.github/workflows/ci-cd.yml): Build EXE on push (Ubuntu runner with Python, PyInstaller), test (pytest if added), deploy artifact (upload EXE/installer to releases). Assume GitHub account; output commands to push.

Output: All files in directory, EXE/installer, md/docx, Git setup commands. Use checkpoints after each step. One-shot with precision/excellence.